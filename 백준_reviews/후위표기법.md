```python
expression = input()

stack = []
ans = ""
for s in expression:
    if s == '+' or s == '-':
        while stack and stack[-1] != '(':
            ans += stack.pop()
        stack.append(s)
    elif s == '*' or s == '/':
        while stack and (stack[-1] == '*' or stack[-1] == '/'):
            ans += stack.pop()
        stack.append(s)
    elif s == '(':
        stack.append(s)
    elif s == ')':
        while stack and stack[-1] != '(':
            ans += stack.pop()
        stack.pop()
    else:
        ans += s

while stack:
    ans += stack.pop()

print(ans)
```

### 배울점

분명히 전에 비슷한 문제를 풀었었던 기억이 있어서 금방 풀 줄 알았지만 해당 과정을 다시 기억하기가 너무 어려웠다. 아무래도 로직 자체는 구현하기 힘들지 않고 할 수 있었는데 왜 이 로직을 사용하면 중위 표기법이 후위 표기법으로 표현되는지 이해가 가지 않았기 때문에 기억에 남지 않는 것 같다. 

로직은 간단하다. 

1. 계산 기호 ( '+', '-', '/' , '*' , '(' , ')' ) 가 아닌 숫자나 문자일 경우 바로 출력한다. 
2. 계산 기호일 경우, 자신보다 우선순위가 낮은 기호가 나올 때까지 빼서 출력한다.
3. '(' 기호는 우선순위가 제일 낮고 ')' 가 나올 시 '('가 나올 때까지 안에 있는 모든 기호들을 출력한다. 
4. '(' 는 무조건 추가한다. 

위의 로직들을 지키면서 해당 중위 표기법을 순회 및 출력하면 후위 표기법이 출력이 된다. 

내가 해석한 로직의 의미는 다음과 같다.

1. 문자나 숫자일 경우는 순서가 바뀔 경우가 없기 때문에 그대로 출력한다.
2. 우선순위가 높은 기호가 더 빨리 출력이 돼야 하니 스택에 우선순위가 낮은 기호를 만나기 전까지 출력을 시킨다.  예를 들어 ``+``는       ``*``보다 일반적으로 늦게 출력이 되어야 하기 때문에 만약 스택에 먼저 ``*``이 있을 경우 우선적으로 ``*``를 출력한다. 
3. ``( )`` 안에 있는 기호들은 내부적으로 2번 로직이 적용되면서 우선적으로 출력이 되어야 한다. 따라서 ``(``를 우선순위를 제일 낮추어 2번 로직에 의해 ``(``보다 먼저 있었던 기호들이 출력이 되는 것을 막고 ``)``이 나왔을 때, ``(``까지의 기호들이 출력되게 한다.  예를 들어 기호 스택이 ``['+' , '*']``가 저장 되어있다. ``(`` 가 추가되면 앞에 기호들이 ``(``이후로 오는 기호들보다 먼저 출력되면 안되기 때문에 ``(``의 우선순위를 최하로 두어 막는다. 그 다음 기호들이 추가된 후, ``)``가 추가되면, ``(``까지의 기호들을 출력하게 된다. 

로직 자체는 코드로 구현하기가 쉬워도 이에 대한 심도 있는 이해가 있지 않으면 금방 까먹는다는 것을 깨달았다. 한 문제를 풀더라도 확실히 이해하고 넘어가도록 하자. 



 

