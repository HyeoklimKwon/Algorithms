### 모음 사전

###### 문제 설명

사전에 알파벳 모음 'A', 'E', 'I', 'O', 'U'만을 사용하여 만들 수 있는, 길이 5 이하의 모든 단어가 수록되어 있습니다. 사전에서 첫 번째 단어는 "A"이고, 그다음은 "AA"이며, 마지막 단어는 "UUUUU"입니다.

단어 하나 word가 매개변수로 주어질 때, 이 단어가 사전에서 몇 번째 단어인지 return 하도록 solution 함수를 완성해주세요.

##### 제한사항

- word의 길이는 1 이상 5 이하입니다.
- word는 알파벳 대문자 'A', 'E', 'I', 'O', 'U'로만 이루어져 있습니다.

------

##### 입출력 예

| word      | result |
| --------- | ------ |
| `"AAAAE"` | 6      |
| `"AAAE"`  | 10     |
| `"I"`     | 1563   |
| `"EIO"`   | 1189   |

##### 입출력 예 설명

입출력 예 #1

사전에서 첫 번째 단어는 "A"이고, 그다음은 "AA", "AAA", "AAAA", "AAAAA", "AAAAE", ... 와 같습니다. "AAAAE"는 사전에서 6번째 단어입니다.

입출력 예 #2

"AAAE"는 "A", "AA", "AAA", "AAAA", "AAAAA", "AAAAE", "AAAAI", "AAAAO", "AAAAU"의 다음인 10번째 단어입니다.

입출력 예 #3

"I"는 1563번째 단어입니다.

입출력 예 #4

"EIO"는 1189번째 단어입니다.



#### 풀이

```python
   alpha_list = ['A', 'E', 'I', 'O', 'U']
    result = 1
    print(word)
    for i in range(len(word)):
        word_index = alpha_list.index(word[i])
        # print(5 - i)
        left_len = len(alpha_list[0:word_index])
        # print(left_len)
        # print("+++++")
        if left_len :
            for k in range(5 - i):
                result += left_len*5**k 
            result += 1
        else :
            result += 1
       
    answer = result - 1
```

처음에는 완전탐색으로 DFS를 쓰면 시간 초과가 날 거 같아서 경우의 수로 풀었다. 물론 두 가지 경우 모두 정답처리가 가능했지만 경우의 수 풀이쪽이 훨씬 빠르고 메모리도 적게 사용함을 확인 할 수 있었다. 

간단하게 로직을 설명하자면 ,

단어가 ``EIO``일 경우, ``A``부터 ``E``까지의 경우의 수 + ``E``부터 ``EI``까지의 경우의 수 + ``EI``부터 ``EIO``까지의 경우의 수를 모두 더해준다. 이때 남은 자리는 5가지의 경우가 올 수 있고 하나씩 남은 자리는 하나씩 공백으로 둘 수 있기 때문에 ``A``부터 ``E``까지의 경우의 수 는 1*5^4 + 1 * 5^3 + 1 * 5^2 + 1* 5 + 1*5^0 + 1(자기 자신)이 된다. 

```python
def solution(word):
    print(word)
    alphabets = ['A', 'E', 'I', 'O', 'U']
    global cnt 
    cnt = 0
    global flag
    flag = False
    
    def dfs(result):
        # print(result)
        global cnt 
        cnt += 1        
        #찾았을떄 True를 반환
        if result == word:
            print("found!")
            return True
        # 못찾았을 경우
        else :
            if len(result) >= 5 :
                return False
            else :
                for alphabet in alphabets:
                    if dfs(result + alphabet):
                        return True
            
    for alphabet in alphabets:
        if dfs(alphabet):
             break
   
            
    answer = cnt
    return answer
```

완전탐색 (DFS)를 이용한 로직이다. A부터 순차적으로 하나씩 더해서 word에 맞는지 확인하며 맞으면 True를, 만약 길이가 5를 넘어가는 순간 탐색을 멈춰야하기 때문에 Fasle를 return해준다. (그냥 return 해줘도 무방하다) 만약 해당 타켓 word와 맞으면 바로 break를 하고 cnt를 출력한다.