### 튜플

###### 문제 설명

셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.

- (a1, a2, a3, ..., an)

튜플은 다음과 같은 성질을 가지고 있습니다.

1. 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)
2. 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2)
3. 튜플의 원소 개수는 유한합니다.

원소의 개수가 n개이고, **중복되는 원소가 없는** 튜플 `(a1, a2, a3, ..., an)`이 주어질 때(단, a1, a2, ..., an은 자연수), 이는 다음과 같이 집합 기호 '{', '}'를 이용해 표현할 수 있습니다.

- {{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, ... {a1, a2, a3, a4, ..., an}}

예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는

- {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}

와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로

- {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}
- {{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}}
- {{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}

는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.

특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.

#### **[제한사항]**

- s의 길이는 5 이상 1,000,000 이하입니다.
- s는 숫자와 '{', '}', ',' 로만 이루어져 있습니다.
- 숫자가 0으로 시작하는 경우는 없습니다.
- s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.
- s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.
- return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.

------

##### **[입출력 예]**

| s                                 | result       |
| --------------------------------- | ------------ |
| `"{{2},{2,1},{2,1,3},{2,1,3,4}}"` | [2, 1, 3, 4] |
| `"{{1,2,3},{2,1},{1,2,4,3},{2}}"` | [2, 1, 3, 4] |
| `"{{20,111},{111}}"`              | [111, 20]    |
| `"{{123}}"`                       | [123]        |
| `"{{4,2,3},{3},{2,3,4,1},{2,3}}"` | [3, 2, 4, 1] |

##### **입출력 예에 대한 설명**

##### **입출력 예 #1**

문제 예시와 같습니다.

##### **입출력 예 #2**

문제 예시와 같습니다.

##### **입출력 예 #3**

(111, 20)을 집합 기호를 이용해 표현하면 {{111}, {111,20}}이 되며, 이는 {{20,111},{111}}과 같습니다.

##### **입출력 예 #4**

(123)을 집합 기호를 이용해 표현하면 {{123}} 입니다.

##### **입출력 예 #5**

(3, 2, 4, 1)을 집합 기호를 이용해 표현하면 {{3},{3,2},{3,2,4},{3,2,4,1}}이 되며, 이는 {{4,2,3},{3},{2,3,4,1},{2,3}}과 같습니다.



```python
def solution(s):
    # 원활한 문자열 탐색을 위해 양 끝 쪽의 {}를 제거 
    s = s[1:-1]
    check_arr = []
    # 문자열을 탐색하면서 {}안에 ,로 구분지어 리스트화 하기 
    for i in range(len(s)):
        # 만약 {를 만나면 
        if s[i] == '{':
            # 전처리를 위해 빈 리스트와 숫자 문자열 생성
            tmp_arr = []
            number = ''
            # } 를 만나기 전까지 
            while s[i] != '}':
                i += 1
                # 만약 숫자를 만나면 임시 숫자문자열에 추가 
                if s[i].isdigit():
                    number += s[i]  
                # ,를 만날 시 쌓인 문자열 정수 변환 후 임시 리스트에 추가 
                elif s[i] == ',' :
                    tmp_arr.append(int(number))
                    number = ''
                elif s[i] == '}':
                    tmp_arr.append(int(number))
                    number = ''
            check_arr.append(tmp_arr)
            
    # 예시 ) 	[[4, 2, 3], [3], [2, 3, 4, 1], [2, 3]]
            
    tmp_tu = []
    # 길이가  1 ~ n 까지 순서대로 처리를 위해 이중 for문 
    for i in range(len(check_arr)):
        for j in range(len(check_arr)):
            if i + 1 == len(check_arr[j]):
                # 현재의 숫자들에서 기존 숫자들의 차집합만 더해주기 
                complement = list(set(check_arr[j])-set(tmp_tu))
                tmp_tu += complement  
    
                   
    answer = tmp_tu
    return answer
```

###### 배운 점

문제 이해는 상당히 쉬운 편이었으나, 이를 문자열에서 다시 계산 가능한 리스트로 변환하는 것이 생각보다 많은 시간과 과정 구현이 소모되었다. 처음에 for문으로 변환하려다 while문이 훨씬 간단하게 구현이 가능하였다. 

다음으로 차집합으로 새로운 요소들을 계속해서 추가하는 방식이었는데 이 경우 set을 이용하여 집합처럼 사용이 가능하였다. 

## 1 테스트 환경

- lst1의 원소는 A, B, C, D
- lst2의 원소는 C, D, E, F
- 데이터 입력

```
lst1 = ['A', 'B', 'C', 'D']
lst2 = ['C', 'D', 'E', 'F']
```

## 2 합집합

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/3/30/Venn0111.svg/120px-Venn0111.svg.png)



```
lst1 = ['A', 'B', 'C', 'D']
lst2 = ['C', 'D', 'E', 'F']
union = list(set(lst1) | set(lst2))
print( union ) # ['C', 'F', 'A', 'E', 'B', 'D']
union = list(set().union(lst1,lst2))
print( union ) # ['C', 'F', 'A', 'E', 'B', 'D']
['F', 'C', 'E', 'D', 'A', 'B']
['F', 'C', 'E', 'D', 'A', 'B']
```

## 3 교집합

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Venn0001.svg/120px-Venn0001.svg.png)



```
lst1 = ['A', 'B', 'C', 'D']
lst2 = ['C', 'D', 'E', 'F']
intersection = list(set(lst1) & set(lst2))
print( intersection ) # ['C', 'D']
intersection = list(set(lst1).intersection(lst2))
print( intersection ) # ['C', 'D']
['D', 'C']
['D', 'C']
```

## 4 [차집합](https://zetawiki.com/wiki/차집합)

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/Venn0100.svg/120px-Venn0100.svg.png)



```
lst1 = ['A', 'B', 'C', 'D']
lst2 = ['C', 'D', 'E', 'F']
complement = list(set(lst1) - set(lst2))
print( complement ) # ['B', 'A']
complement = list(set(lst1).difference(lst2))
print( complement ) # ['A', 'B']
['A', 'B']
['A', 'B']
```

## 5 [대칭차집합](https://zetawiki.com/wiki/대칭차집합)

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/Venn0110.svg/120px-Venn0110.svg.png)



```
lst1 = ['A', 'B', 'C', 'D']
lst2 = ['C', 'D', 'E', 'F']
sym_diff = list(set(lst1) ^ set(lst2))
print( sym_diff ) # ['F', 'E', 'A', 'B']
sym_diff = list(set(lst1).symmetric_difference(lst2))
print( sym_diff ) # ['F', 'E', 'A', 'B']
['F', 'E', 'B', 'A']
['F', 'E', 'B', 'A']
```