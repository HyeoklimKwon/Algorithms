# 3주차: 알고리즘

# 시간복잡도

시간복잡도 : 연산의 횟수를 점근적 표기법을 통해 추상적으로 표현

- 실제 걸리는 시간을 측정
- 실행되는 명령문의 개수를 계산 (명령문 = 연산)

시간 복잡도 ≒ (빅-오(O) 표기법) - 이 외에도 Big- Ω, Big-Θ  표기법이 있다.

- 빅-오 표기법(Big-Oh Notation)
- 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시
- 계수 (Coefficient)는 생략하여 표시

약 10억번의 계산에 1초가 걸린다고 생각할 수 있다.

Big-O : 최악의 경우 ?번 수행되면 프로그램을 끝낼 수 있다

![https://blog.kakaocdn.net/dn/bpoQ1P/btrJKsFdpl3/8SCK0QoWHOjOCBuX8KTNKk/img.jpg](https://blog.kakaocdn.net/dn/bpoQ1P/btrJKsFdpl3/8SCK0QoWHOjOCBuX8KTNKk/img.jpg)

Big-Omega :최소 ?번은 수행되어야 프로그램을 끝낼 수 있다

![https://blog.kakaocdn.net/dn/v2xhj/btrJGT4m6jn/pGZOx9UDVfsKRFK1VmBtb0/img.jpg](https://blog.kakaocdn.net/dn/v2xhj/btrJGT4m6jn/pGZOx9UDVfsKRFK1VmBtb0/img.jpg)

Big-Theta : 최소와 최악의 평균적인 복잡도

![https://blog.kakaocdn.net/dn/DDKGY/btrJItYHkCy/KQtjGxyEmS1UkJMLYui0K1/img.jpg](https://blog.kakaocdn.net/dn/DDKGY/btrJItYHkCy/KQtjGxyEmS1UkJMLYui0K1/img.jpg)

# 정렬(버블, 선택, 퀵, 병합, 삽입)

단순(구현 간단)하지만 비효율적인 방법

- 삽입 정렬, 선택 정렬, 버블 정렬

복잡하지만 효율적인 방법

- 퀵 정렬, 힙 정렬, 합병 정렬, 기수 정렬
- [참고할만한 사이트](<[https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html](https://gmlwjd9405.github.io/2018/05/06/algorithm-insertion-sort.html)>)

## 버블정렬

### 시간복잡도 O(n\*\*2)

서로 인접한 두 원소를 검사하여 정렬하는 알고리즘

인접한 2개의 레코드를 비교하여 크기가 순서대로 되어있지 않으면 서로 교환

선택 정렬과 기본 개념이 유사함

1회전을 수행하고 나면 가장 큰 자료가 맨 뒤로 이동

## 삽입 정렬

### 시간복잡도 O(n\*\*2)

자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교하여 자신의 위치를 찾아 삽입하여 정렬을 완성시키는 알고리즘

매 순서마다 해당 원소를 삽입할 수 있는 위치를 찾아 해당 위치에 넣는다

삽입 정렬은 두 번째 자료부터 시작하여 그 앞(왼쪽)의 자료들과 비교하여 삽입할 위치를 지정한 후 자료를 뒤로 옮기고 지정한 자리에 자료를 삽입하여 정렬하는 알고리즘이다.
즉, 두 번째 자료는 첫 번째 자료, 세 번째 자료는 두 번째와 첫 번째 자료, 네 번째 자료는 세 번째, 두 번째, 첫 번째 자료와 비교한 후 자료가 삽입될 위치를 찾는다. 자료가 삽입될 위치를 찾았다면 그 위치에 자료를 삽입하기 위해 자료를 한 칸씩 뒤로 이동시킨다.
처음 Key 값은 두 번째 자료부터 시작한다.

## 퀵 정렬

### 시간복잡도 O(n\*\*2)

분할 정복 알고리즘의 하나, 평균적으로 매우 빠른 수행 속도를 가진다

병합 정렬과 달리 퀵 정렬은 리스트를 비균등하게 분할

분할(Divide): 입력 배열을 피벗을 기준으로 비균등하게 2개의 부분 배열(피벗을 중심으로 왼쪽: 피벗보다 작은 요소들, 오른쪽: 피벗보다 큰 요소들)로 분할

정복(Conquer): 부분 배열을 정렬한다. 부분 배열의 크기가 충분히 작지 않으면 순환 호출 을 이용하여 다시 분할 정복 방법을 적용

결합(Combine): 정렬된 부분 배열들을 하나의 배열에 합병

순환 호출이 한번 진행될 때마다 최소한 하나의 원소(피벗)는 최종적으로 위치가 정해지므로, 이 알고리즘은 반드시 끝난다는 것을 보장할 수 있다.

## 선택 정렬

### 시간복잡도 O(n\*\*2)

제자리 정렬(in-place sorting) 알고리즘의 하나

입력 배열(정렬되지 않은 값들) 이외에 다른 추가 메모리를 요구하지 않는 정렬 방법

해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘

첫 번째 순서에는 첫 번째 위치에 가장 최솟값을 넣는다.

두 번째 순서에는 두 번째 위치에 남은 값 중에서의 최솟값을 넣는다.

…
과정 설명

- 주어진 배열 중에서 최솟값을 찾는다.
- 그 값을 맨 앞에 위치한 값과 교체한다(패스(pass)).
- 맨 처음 위치를 뺀 나머지 리스트를 같은 방법으로 교체
- 1개의 원소만 남을 때까지 위의 과정을 반복

```python
def SelectionSort(A):
	n = len(A)
	for i in range(0, n - 1):
		minI = i
		for j in range(i + 1, n):
			if A[j] < A[minI]"
				minI = j
		A[minI], A[i] = A[i], A[minI]
```

### 시간복잡도

비교 횟수

- 두 개의 for 루프의 실행 횟수
- 외부 루프: (n-1)번
- 내부 루프(최솟값 찾기): n-1, n-2, … , 2, 1 번

교환 횟수

- 외부 루프의 실행 횟수와 동일. 즉, 상수 시간 작업
- 한 번 교환하기 위하여 3번의 이동(SWAP 함수의 작업)이 필요하므로 3(n-1)번
- T(n) = (n-1) + (n-2) + … + 2 + 1 = n(n-1)/2 = **O(n^2)**

## 병합정렬

### 시간복잡도 O(nlogn)

### 병합 정렬 과정

- {9, 10, 2, 13, 16, 8, 31, 22}를 병합 정렬하는 과정
- 분할 단계: 전체 자료 집합에 대하여, 최소 크기의 부분집합이 될 때까지 분할 작업을 계속한다.
- 병합 단계: 2개의 부분집합을 정렬하면서 하나의 집합으로 병합
- 8개의 부분집합이 1개로 병합될 때까지 반복함

### 분할과정

```html
merge_sort(LIST m) IF length(m) == 1: RETURN m LIST left, right middle <-
length(m) /2 FOR x in m berfore middle add x to left FOR x in m after or equal
middle add x to right left <- merge_sort(left) right <- merge_sort(right) RETURN
merge(left, right)
```

### 병합과정

```html
merge(LIST left, LIST right) LIST result WHILE length(left) > 0 OR length(right)
> 0 IF length(left) > 0 ANS length(right) > 0 IF first(left) <= first(right)
append popfirst(left) to result ELSE append popfirst(right) to result ELIF
length(left) > 0 append popfirst(left) to result ELIF append popfirst(right) to
result RETURN result
```

# 재귀

### 재귀: 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법

- 하나의 큰 문제를 해결할 수 있는(해결하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합한다.
- 재귀 함수로 구현

재귀 함수 (recursive function)

- 함수 내부에서 직/간접적으로 자기 자신을 호출하는 함수
- 기본 부분(basis part)와 유도 부분(inductive part)로 구성됨
- 함수 호출은 프로그램 메모리 구조에서 스택 이용
- 재귀 호출은 반복적인 스택의 사용으로 메모리 및 속도에서 성능저하가 발생할 수 있다.

# DP

복잡한 문제를 여러 개의 문제로 나누어 푸는 방법

최적성의 원리를 만족하는지 판단

- 큰 문제를 작은 문제로 쪼갤 수 있다
- 작은 문제에서 구한 정답이 그것을 포함하는 큰 문제에서도 동일

중복 연산을 방지하기 위한 방법

1. Memoization(하향식)
   1. 하위 문제에 대해 정답을 계산했는지 확인
2. Tabulation(상향식)
   1. 작은 문제의 정답을 이용해서 큰 문제의 정답을 풀이

참고)

분할정복과의 차이 : 부분 문제의 중복

다이나믹 프로그래밍은 각 부분 문제들이 서로 영향을 미치며 중복, 하지만 분할 정복은 동일한 부분문제가 반복적으로 계산되진 않는다.

# 그래프 기초(dfs, bfs, 백트래킹)

### DFS(깊이우선탐색)

- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색해 가다가 더 이상 갈 곳이 없게 되면, 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 방문하는 순회방법
- 가장 마지막에 만났던 갈림길의 정점으로 되돌아가서 다시 깊이 우선 탐색을 반복해야 하므로 후입선출 구조의 스택 사용

## BFS(Breadth First Search)

- 너비우선탐색은 탐색 시작점의 인접한 정점들을 먼저 모두 차례로 방문한 후에, 방문했던 정점을 시작저믕로 하여 다시 인접한 정점들을 차례로 방문하는 방식
- 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출형태의 자료구조인 큐를 활용함

## 백트래킹

해를 찾아가는 도중, 지금의 경로가 해가 될 것 같지 않으면 그 경로를 더이상 가지 않고 되돌아가는 알고리즘

가지치기라고 하기도 함, 불필요한 부분을 쳐내고 최대한 올바른 쪽으로 간다

효율성을 높일 수 있다.

모든 가능한 경우의 수 중, 특정한 조건을 만족하는 경우만 살펴보는 것

# MST(최소 신장 트리)

- 그래프에서 최소 비용 문제
  - 1. 모든 정점을 연결하는 간선들의 가중치의 합이 최소가 되는 트리
  - 2. 두 정점 사이의 최소 비용의 경로 찾기
- 신장 트리
  - n개의 정점으로 이루어진 무방향 그래프에서 n개의 정점과 n-1개의 간선으로 이루어진 트리
- 최소 신장 트리(Minimum Spanning Tree)
  - 무방향 가중치 그래프에서 신장 트리를 구성하는 간선들의 가중치의 합이 최소인 신장 트리

### Prim 알고리즘

- 하나의 정점에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어가는 방식1) 임의 정점을 하나 선택해서 시작2) 선택한 정점과 인접하는 정점들 중의 최소 비용의 간선이 존재하는 정점을 선택3) 모든 정점이 선택될 때 까지 1), 2), 과정을 반복
- 서로소인 2개의 집합(2, disjoint-sets) 정보를 유지
  - 트리 정점들(tree vertices) - MST를 만들기 위해 선택된 정점들
  - 비트리 정점들(nontree vertices) - 선택 되지 않은 정점들

### KRUSKAL 알고리즘

- 간선을 하나씩 선택해서 MST를 찾는 알고리즘1) 최초, 모든 간선을 가중치에 따라 오름차순으로 정렬2) 가중치가 가장 낮은 간선부터 선택하면서 트리를 증가시킴
  - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택3) n-1 개의 간선이 선택될 때까지 2)를 반복

# 그래프 심화 (벨만포드/다익스트라/플로이드와샬)

최단 경로

- 최단 경로 정의
  - 간선의 가중치가 있는 그래프에서 두 정점 사이의 경로들 중에 간선의 가중치의 합이 최소인 경로
- 하나의 시작 정점에서 끝 정점까지의 최단경로
  - 다익스트라(dijkstra) 알고리즘
    - 음의 가중치를 허용하지 않음
  - 벨만-포드(Bellman-Ford) 알고리즘
    - 음의 가중치 허용
- 모든 정점들에 대한 최단 경로
  - 플로이드-워샬(Floyd-Warshall) 알고리즘

## Dijkstra 알고리즘

- 시작 정점에서 거리가 최소인 정점을 선택해 나가면서 최단 경로를 구하는 방식이다.
- 시작정점(s) 에서 끝정점(t) 까지의 최단 경로에 정점 x가 존재한다.
- 이때, 최단경로는 s에서 x까지의 최단 경로와 x에서 t까지의 최단경로 구성된다.
- 탐욕 기법을 사용한 알고리즘으로 MST의 프림 알고리즘과 유사하다

## 벨만포드

한 노드에서 다른 노드까지의 최단 거리를 구하는 알고리즘

다익스트라 알고리즘 : 모든 가중치가 양수인 경우에만 사용 가능

벨만-포드 알고리즘 : 노드 간의 간선 가중치가 음수인 경우에도 사용

시간 복잡도는 벨만-포드가 더 크기 때문에 가중치가 모두 양수라면 굳이 벨만-포드를 사용할 필요 없음

1. 시작 노드를 설정한다.
2. 시작 노드에서 각 다른 노드의 거리 값을 무한대로 설정하고 시작 노드를 0으로 설정한다.
3. 현재 노드의 모든 인접 노드를 탐색하며 기존에 저장된 인접 노드까지의 거리보다 현재 노드를 거치고 인접 노드에 도달하는 게 더 짧을 경우 값을 갱신한다.
4. 3의 과정을 모든 노드에 대해 수행한다.
5. 모든 노드에 3 - 4를 수행하고서 또 거리가 갱신된다면 −∞를 발생시키는 음수 사이클이 존재함을 의미한다.

   ```python
   INF = float('inf')
   V, E = map(int, input().split())
   edges = []
   for _ in range(E):
       s, d, w = map(int, input().split())
       edges.append((s, d, w))
   def bellman-ford(start):
       dist = [INF] * (V + 1)
       dist[start] = 0
       for i in range(V):
           for s, d, w in edges:
               if dist[s] != INF and dist[d] > dist[s] + w:
                   if i == V - 1:
                       return -1
                   dist[d] = dist[s] + w
       return dist

   print(bellman-ford(0))
   ```

   [참고 사이트](<[https://8iggy.tistory.com/153](https://8iggy.tistory.com/153)>)

## Floyd-Warshall Algorithm 플로이드와샬

다익스트라 : 한 지점에서 다른 지점으로 가는 최단거리만 제공, 모든 지점의 거리를 확인하기 위해서 각각의 지점에 대해 다익스트라를 한번씩 돌려야 하는 번거로움이 있다.

모든 쌍에 대해 최단거리를 구해야 하는 상황에서 사용하기 좋은 알고리즘

다익스트라와 유사한 아이디어이지만 A→B 경로보다 A→X→B로 가는 경로가 더 짧은 경우 갱신 진행

경유할 점을 1번 노드부터 N번 노드로 확장해가며, `dist[i][j]` 가 `dist[i][k] + dist[k][j]` 보다 크다면 갱신해주는 방식

```python
function floyd(graph)
    set dist = |V| * |V| array initialized to INF  // 처음 dist 배열을 INF로 초기화
    for each edge(u, v)                            // 주어진 그래프의 모든 간선에 대해
        dist[u][v] = length(u, v)                  // 각 간선의 가중치를 dist 배열에 저장
    for k = 1 ... |V|                              // 확실하게 지나갈 정점을 1번부터 V번까지 순서대로 정의
        for i = 1 ... |V|                          // 고정된 k에 대해 모든 쌍 (i, j) 확인
            for j = 1 ... |V|
                if dist[i][j] > dist[i][k] + dist[k][j]     // i에서 j로 가는 거리가 k를 경유가 더 짧은 경우
                    dist[i][j] = dist[i][k] + dist[k][j]    // dist[i][j]값을 갱신
    return dist
```

# 분할정복/이분탐색(이진탐색)

## 분할정복

### 설계 전략

- 분할 : 해결할 문제를 여러 개의 작은 부분으로 나눈다.
- 정복 : 나눈 작은 문제를 각각 해결한다.
- 통합 : (필요하다면) 해결된 해답을 모은다.

분할 정복 방법은 대개 순환 호출을 이용하여 구현

Base Case: 이미 문제가 충분히 작아서, 더 작은 부분 문제로 나누지 않아도 바로 답을 알 수 있는 경우

Recursive case: 문제가 커서 바로 답을 알 수 없어서 같은 형태의 부분 문제들로 쪼개서 풀어야 하는 경우

## 이진탐색

### 시간복잡도 O(log N)

정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법

시작점, 끝점, 중간점을 이용하여 탐색 범위를 설정

### Python 이진 탐색 라이브러리

bisect_left(a, x) : 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 왼쪽 인덱스를 반환.

Bisect_right(a,x) : 정렬된 순서를 유지하면서 배열 a에 x를 삽입할 가장 오른쪽 인덱스를 반환

```python
from bisect import bisect_left, bisect_right
a = [1,2,4,4,8]
x = 4
print(bisect_left(a,x)) # 2
print(bisect_right(a,x)) # 4
```

# 그리디

탐욕 알고리즘의 최적해 조건

### 탐욕적 선택 속성(greedy choice property)

- 탐욕적 선택은 최적해로 갈 수 있음을 보여라.
  - 즉, 탐욕적 선택은 항상 안전하다.

### 최적 부분 구조(optimal substructure property)

- 최적화 문제를 정형화하라
  - 하나의 선택을 하면 풀어야 할 하나의 하위 문제가 남는다.

### [원문제의 최적해 = 탐욕적 선택 + 하위 문제의 최적해] 임을 증명하라

매 단계에서 가장 좋게 보이는 것을 빠르게 선택한다.
