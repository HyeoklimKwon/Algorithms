# 5주차 운영체제

운영체제

1. 프로세스와 스레드의 차이
2. 데드락
3. 세마포어 & 뮤텍스
4. 컨텍스트 스위칭
5. 선점형 스케줄링 비선점형 스케줄링
6. paging system segmentation system
7. paging algorithm
8. caching
9. 가상 메모리(단편화) + page fault
10. 메모리 구조
11. 디스크 스케줄링
12. raid

# 프로세스와 스레드의 차이

운영체제 : 사용자가 실행하는 프로그램을 위한 프로그램, 사용자가 실행하는 응용프로그램이 올바르게 실행되도록 돕고 필요한 자원을 할당해주는 프로그램

## 프로세스(Process) : 실행 중인 프로그램

- 일반적으로 1개의 CPU는 한 번에 하나의 프로세스만 실행, CPU는 프로세스들을 번갈아 가며 실행
- 여러 프로세스가 동시에 실행되는 환경에서 ‘프로세스 동기화’가 필수적
- 프로세스가 꼼짝도 못하고 더 이상 실행되지 못하는 상황인 ‘교착 상태’를 해결해야 함
- unix 운영체제에서 확인 방법 : ps -ef 명령어 사용

### 포그라운드 프로세스(foreground process)

사용자가 보는 앞에서 실행되는 프로세스

### 백그라운드 프로세스(background process)

사용자가 보지 못하는 뒤편에서 실행되는 프로세스

- 사용자와 직접 상호작용 할 수 있는 백그라운드 프로세스
- 사용자와 상호작용하지 않고 정해진 일만 수행하는 백그라운드 프로세스 - 유닉스 운영체제 : 데몬(daemon), 윈도우 운영체제 : 서비스(service)

### 프로세스의 메모리 영역

1. 코드 영역(텍스트 영역)
   1. 실행할 수 있는 코드가 저장(기계어로 이루어진 명령어)
   2. 읽기 전용 공간
   3. 정적 할당 영역
2. 데이터 영역
   1. 프로그램에서 실행할 동안 유지할 데이터 저장
   2. 정적 할당 영역
3. 힙 영역
   1. 프로그래머가 직접 할당할 수 있는 저장 공간
   2. 힙 영역에 메모리 공간 할당 시 언젠가 해당 공간 반환 필요 - 반환하지 않는 경우 메모리 누수 발생
   3. 동적 할당 영역
   4. 낮은 주소에서 높은 주소로 할당
4. 스택 영역
   1. 데이터를 일시적으로 저장하는 공간
   2. 동적 할당 영역
   3. 높은 주소에서 낮은 주소로 할당

## 스레드(Thread): 프로세스를 구성하는 실행의 흐름 단위

- 하나의 프로세스는 여러 개의 스레드를 가질 수 있다
- 스레드로 하나의 프로세스에서 여러 부분을 동시에 실행할 수 있다
- 실행에 필요한 최소한의 정보만을 유지한 채 프로세스 자원을 공유하여 실행됨

유닉스는 프로세스와 스레드라는 말 대신 task라는 이름으로 모두 실행의 문맥이라는 점에서 동등하다고 간주

## 멀티 프로세스

여러 프로세스를 동시에 실행

기본적으로 프로세스끼리는 자원을 공유하지 않음

- 장점
  - 각 프로세스는 독립된 메모리 공간을 가지기 때문에, 하나의 프로세스에서 오류가 발생해도 다른 프로세스는 영향을 받지 않음
  - 여러 개의 프로세스가 동시에 실행되기 때문에, 여러 작업을 병렬로 처리 가능
  - 프로세스는 운영체제에서 할당하는 자원에 따라 실행되므로, 시스템 자원이 늘어남에 따라 프로세스 수를 증가시켜 시스템의 확장성을 높일 수 있음
- 단점
  - 프로세스 간 통신 오버헤드: 프로세스 간 통신을 위해서는 IPC(Inter-Process Communication) 메커니즘이 필요하며, 이는 추가적인 오버헤드를 발생 시킴
  - 각 프로세스는 독립된 메모리 공간을 가, 메모리와 CPU 등의 자원을 많이 소모

## 멀티 스레드

여러 스레드로 프로세스를 동시에 실행

같은 프로세스 내의 자원을 공유

데이터 공유 및 통신이 용이

- 장점
  - 프로세스 내에서 자원을 공유 → 프로세스 간 통신보다 더 적은 자원을 사용, 프로세스 간 통신보다 빠르게 실행
  - 병렬로 실행되는 작업을 하나의 프로세스 내에서 처리 → 프로그램의 구조 단순
  - context switching이 활발하게 일어남
- 단점
  - 여러 개의 스레드가 동시에 공유하는 자원에 접근할 때, 동기화 문제 발생
  - 여러 스레드가 동시에 실행 → 버그 재현, 디버깅이 어려움
  - 교착 상태 발생 가능

# 데드락(교착상태)

일어나지 않을 사건을 기다리며 진행이 멈추는 현상

자원 할당 그래프로 교착 상태 표현 가능

1. 상호배제
   1. 해당 자원을 한 번에 하나의 프로세스만 이용 가능
   2. 한 프로세스가 사용하는 자원을 다른 프로세스가 사용할 수 없는 상황
2. 점유와 대기
   1. 자원을 할당받은 상태에서 다른 자원을 할당받기를 기다리는 상태
3. 비선점
   1. 그 자원을 이용하는 프로세스의 작업이 끝나야 이용 가능
   2. 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못함
4. 원형대기
   1. 프로세스들과 프로세스가 요청 및 할당받은 자원이 원의 형태를 이룸

### 교착 상태 예방

교착 상태의 발생 조건 중 하나를 충족하지 못하게 하는 방법

### 교착 상태 회피

안전 상태를 유지할 수 있는 경우에만 자원을 할당

### 교착 상태 검출 후 회복

교착 상태 발생 여부를 주기적으로 검사, 교착 상태가 발생하면 그때 그때 회복하는 방식

# 세마포어 & 뮤텍스

## 세마포어

멀티 프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법

임계 구역(Critical Section)

여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분

공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에, 한 프로세스가 임계 구역을 수행할 때 다른 프로세스가 접근하지 못하도록 해야 함

## 뮤텍스

임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술

상호배제의 약자

해당 접근을 조율하기 위해 lock, unlock 사용

lock : 현재 임계 구역에 들어갈 권한을 얻어옴 (만약 다른 프로세스/스레드가 임계 구역 수행 중이면 종료할 때까지 대기)

unlock : 현재 임계 구역을 모두 사용했음을 알림 (대기 중인 다른 프로세스/스레드가 임계 구역에 진입할 수 잉ㅆ음)

뮤텍스는 상태가 0, 1로 이진 세마포어로 부르기도 함

# 컨텍스트 스위칭

여러개의 프로세스가 실행되고 있을 때 기존에 실행되던 프로세스를 중단하고 다른 프로세스를 실행하는 것

CPU에 실행할 프로세스를 교체하는 기술

context switching

## 세마포어와 뮤텍스

세마포어와 뮤텍스는 공유자원에 여러 프로세스 혹은 스레드가 접근하는 것을 제어하기 위해 사용하는 동기화 기법입니다. 세마포어는 카운팅 세마포어와 이진 세마포어가 있으며, 뮤텍스는 이진 세마포어와 유사한 방식으로 동작합니다.

## 컨텍스트 스위칭

컨텍스트 스위칭은 여러 개의 프로세스나 스레드가 동시에 실행될 때, 현재 실행 중인 프로세스나 스레드의 상태를 보관하고 다음 실행될 프로세스나 스레드의 상태를 복원하는 과정

이는 운영체제가 CPU의 시간을 효율적으로 사용하기 위해 필요한 작업

# 선점형 스케줄링 비선점형 스케줄링

CPU 스케줄링 : 운영체제가 프로세스들에게 공정하고 합리적으로 CPU자원을 배분

입출력 집중 프로세스 : 실행 상태보다는 입출력을 위한 대기 상태에 많이 머무르게 됨

CPU 집중 프로세스 : 대기 상태보다 실행 상태에 많이 머무르게 됨

## 선점형 스케줄링

프로세스가 cpu를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로레스에 할당할 수 있는 스케줄링 방식을 의미

어느 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식

더 급한 프로세스가 언제든 끼어들어 사용할 수 있는 스케줄링 방식

어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원 배분 가능

문맥 교환 과정에서 오버헤드 발생 가능

## 비선점형 스케줄링

하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지 다른 프로세스가 끼어들 수 없는 스케줄링 방식

하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식

오버헤드는 선점형 스케줄링보다 적지만 모든 프로세스가 골고루 자원을 사용할 수 없다

# paging system segmentation system

## 페이징(Paging) - 고정크기

하나의 프로세스가 사용하는 메모리 공간이 연속적이어야 한다는 제약을 깨는 메모리 관리 방법 물리 메모리는 Frame이라는 고정된 크기로 분리되고 논리 메모리(프로세스가 점유하는)는 page라고 불리는 고정 크기 블록으로 분리됨. 페이징을 통해 논리 메모리는 물리 메모리에 저장될 때 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절하게 배치됨으로 외부 단편화 해결 하나의 프로세스가 사용하는 공간은 여러 페이지로 나뉘어 관리되고 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 mapping되어 저장된다.

단점: 역으로 내부단편화의 비중이 증가. page에 여유공간이 남게 되는 경우가 많기 때문

## 세그멘테이션(Semgentation) - 가변 크기

서로 다른 크기의 논리적 단위인 세그먼트로 분활함. 내부 단편화 문제를 해소하기 위한 방법. 메모리 상 효율이 개선되고 동적 분할을 통한 오버헤드가 감소함

단점: 외부단편화 문제 해결 불가, 서로 다른 크기의 스그먼트들이 적재되고 제거되다보면 빈 공간이 많은 수의 작은 조각으로 나뉘어 사용하지 못하게 되기 떄문

# paging algorithm

## 페이지 교체 알고리즘

페이지 교체 알고리즘은 물리적 메모리에 모두 적재할 수 없는 프로세스의 페이지 중 어떤 페이지를 물리적 메모리에 적재할지를 결정하는 알고리즘

- FIFO (First In First Out)
  - 페이지를 적재한 시간을 기준으로 가장 오래된 페이지를 교체하는 알고리즘
- LRU (Least Recently Used)
  - 가장 오래 사용되지 않은 페이지를 교체하는 알고리즘
- LFU (Least Frequently Used)
  - 사용 빈도가 가장 적은 페이지를 교체하는 알고리즘
- Optimal
  - 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 알고리즘
  - 이론적으로 가장 최적의 알고리즘

##

# caching

캐시 메모리는 속도가 빠른 장치와 느린 장치 간의 속도차에 따른 병목 현상을 줄이기 위한 범용 메모리이다.

## 캐시란?

자주 사용되는 데이터나 값을 미리 복사해 놓는 임시 장소를 가르킴.

## 배경

CPU처리속도는 급격히 증가하엿지만, 메모리 접근 속도는 늘어나지 못함, 메모리와 CPU사이에 위치하여 접근 시간을 줄임

## 장점

- 캐시에 데이터를 미리 복사해 놓으면 계산이나 접근 시간 없이 더 빠른 속도로 데이터에 접근 할 수 있음.
- 접근 시간에 비해 원래 데이터에 접근하는 시간이 오래 걸리는 경우, 혹은 값을 다시 계산하는 시간을 절약하고 하는 경우에 사용

## 단점

= 캐시(Cache)는 캐시(Cash)다. 비싸다. 메모리 저장곤간은 속도가 빠를수록 용량이 작고, 가격이 높다

# 가상 메모리(단편화) + page fault

## Page Fault

CPU가 무효 비트로 표시된 페이지에 엑세스하는 상황을 Page Fault

CPU가 무효 Page에 접근하면 MMU가 page fault trap을 발생시켜 처리

프로세스는 물리적 메모리에 모두 올라가지 않고 필요한 페이지만 동적으로 적재

물리적 메모리에 없는 페이지를 참조하면 페이지 폴트가 발생

운영체제는 해당 페이지를 디스크에서 읽어와 물리적 메모리에 적재한 후 프로세스를 다시 실행

# 메모리 구조

## 메모리의 구조에 대해 알아보자

프로그램이 실행되기 위해서는 먼저 프로그램이 메모리에 load 되어야 한다. 컴퓨터의 운영체제는 프로그램의 실행을 위해 다양한 메모리 공간을 제공한다. 대표적인 메모리 공간은 크게 4가지로 나뉜다.

1. 코드(code) 영역
2. 데이터(data) 영역
3. 스택(stack) 영역
4. 힙(heap) 영역

[참고자료](http://www.tcpschool.com/c/c_memory_structure)

[https://camo.githubusercontent.com/8da7339b2f33348d3fd7c26d317b0a97d8b42eb823842a1e54d0a8a328e6323c/687474703a2f2f7777772e7463707363686f6f6c2e636f6d2f6c656374757265732f696d675f635f6d656d6f72795f7374727563747572652e706e67](https://camo.githubusercontent.com/8da7339b2f33348d3fd7c26d317b0a97d8b42eb823842a1e54d0a8a328e6323c/687474703a2f2f7777772e7463707363686f6f6c2e636f6d2f6c656374757265732f696d675f635f6d656d6f72795f7374727563747572652e706e67)

### 1.코드 영역

메모리의 코드 영역은 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 부른다. CPU는 코드 영역에 저장된 명령어를 하나씩 가져가서 처리한다.

### 2. 데이터 영역

메모리의 데이터 영역은 프로그램의 전역 변수와 정적 변수가 저장되는 영역이다. 프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸한다.

### 3. 스택 영역

메모리의 스택 영역은 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다. 스택 영역은 함수의 호출과 함께 할당되며, 함수의 호출이 완료되면 소멸한다. 스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 한다.

스택 영역은 push 동작으로 데이터를 저장하고 pop 동작으로 데이터를 인출한다. 이러한 스택은 후입선출(LIFO, Last in First out) 방식에 따라 동작하므로, 가장 늦게 저장된 데이터가 가장 먼저 인출된다. 스택 영역은 메모리의 높은 주소에서 낮은 주소의 방향으로 할당된다.

### 4. 힙 영역

메모리의 힙 영역은 사용자가 직접 관리할 수 있는 그리고 해야만 하는 메모리 영역이다. 힙 영역은 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다. 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.

> 여기서 잠깐! 자료구조 힙과 이 힙 영역은 같은 힙일까? https://www.inflearn.com/questions/163538 결론 : 아니다

# 디스크 스케줄링

### 스케줄링

`CPU를 적절하고 효율적으로 사용할 수 있도록 하는 작업`

### 스케줄러 (Scheduler)

`한정적인 메모리를 여러 프로세스가 효율적으로 사용할 수 있도록 다음 실행 시간에 실행할 수 있는 프로세스 중에 하나를 선택하는 역할

스케줄러 종류

1. 장기 스케줄러/ 잡 스케줄러
2. 단기 스케줄러/ CPU 스케줄러
3. 중기 스케줄러/ 스와퍼
   > https://dheldh77.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%9F%ACSchedule`

# RAID

RAID(Redundant Array of Inexpensive Disks)는 여러 개의 디스크를 묶어서 하나의 디스크처럼 사용하는 기술

여러 개의 디스크를 사용함으로써 데이터의 안정성과 성능을 향상시키는데 목적

RAID의 종류는 다음과 같다.

- RAID 0
  - 데이터를 여러 개의 디스크에 나누어 저장하는 방식
  - 데이터의 안정성은 낮지만 속도는 빠르다.
- RAID 1
  - 미러링 방식으로 데이터를 여러 개의 디스크에 중복 저장하는 방식
  - 데이터의 안정성은 높지만 용량은 감소한다.
- RAID 5
  - 여러 개의 디스크에 데이터를 분산하여 저장하는 방식
  - 데이터의 안정성은 높으면서 용량도 유지할 수 있다.
- RAID 6
  - RAID 5와 유사하지만, 2개의 패리티 정보를 저장하여 더 높은 안정성을 가진다.
